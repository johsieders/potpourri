# Integers over a prime p
# trying to understand modular arithmetic
# generated by GPT
# checked 08/01/2024

from typing import Sequence

from euclidian_rings import EuclidianRing
from fields import Field
from primes import chinese_remainder, inv

epsilon = 1e-8


class Mp(Field):
    """
    This class implements modular arithmetic by means of one or more coprime elements.
    It works on any class that implements a Euclidean Ring.
    If coprimes contains just one prime element p you get Fp.
    If p is not prime, everything works fine, but you get zero divisors if gcd(a, p) > 1.
    So the div method catches the exception thrown by inv and returns None
    If coprimes contains two or more coprime elements, say (p0, p1), you get
    modular arithmetic mod (p0, p1). All arithmetic operations are performed elementwise.
    The single number represented by the tuple is obtained by te chinese_remainder method.
    """

    def __init__(self, v, coprimes: Sequence):
        """
        :param v: Sequence of elements of an Euclidian Field (e.g. int or polynomials)
        :param coprimes: Sequence of coprimes of an Euclidian Field
        """
        # print(f"initializing {v} {coprimes}")

        if isinstance(v, int) or isinstance(v, EuclidianRing):
            self.values = [v % p for p in coprimes]
        elif len(v) != len(coprimes) or len(v) == 0:
            raise ValueError(f"invalid input: {v}, {coprimes}")
        else:
            self.values = [x % p for x, p in zip(v, coprimes)]

        self.coprimes = tuple(coprimes)

        N = 1
        for p in coprimes:
            N *= p

        self.is_zero_divisor = False
        for x in self.values:
            if x == 0 or N % x == 0:
                self.is_zero_divisor = True
                break

    def transform(self, v):
        return v if isinstance(v, Mp) else Mp([v], self.coprimes)

    def eq(self, b):
        for a, b in zip(self.values, b.values):
            if a != b:
                return False
        return True

    def __bool__(self):
        return not self.is_zero_divisor

    def add(self, b):
        v = [(self.values[i] + b.values[i]) for i in range(len(self.values))]
        return Mp(v, self.coprimes)

    def sub(self, b):
        v = [(self.values[i] - b.values[i]) for i in range(len(self.values))]
        return Mp(v, self.coprimes)

    def mul(self, b):
        v = [self.values[i] * b.values[i] for i in range(len(self.values))]
        return Mp(v, self.coprimes)

    def div(self, b):
        v = [self.values[i] * inv(b.values[i], b.coprimes[i]) for i in range(len(b.values))]
        return Mp(v, self.coprimes)

    def __abs__(self):
        return chinese_remainder(self.values, self.coprimes)

    def __str__(self):
        return f"{abs(self)}(mod {' '.join([str(p) for p in self.coprimes])})"
