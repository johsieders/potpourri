# js 4.10.2023
# first draft generated by gpt-4

import random
import re

from Metaphone import doublemetaphone


def k_medoids(K: int, xs: list, dist: callable) -> list:
    """
    :param K: number of clusters to be computed
    :param xs: list of strings to b
    :param dist: function
    :return: list of
    """
    # Initialize K random medoids
    medoids = random.sample(xs, K)
    clusters = {medoid: [] for medoid in medoids}

    while True:
        # Step 1: Associate each string with the nearest medoid
        for x in xs:
            closest_medoid = min(medoids, key=lambda medoid: dist(medoid, x))
            clusters[closest_medoid].append(x)

        # Step 2: Update each medoid to be the most central point of each cluster
        new_medoids = []
        for medoid, cluster in clusters.items():
            new_medoid = min(cluster, key=lambda x: sum(dist(x, y) for y in cluster))
            new_medoids.append(new_medoid)

        # Check for convergence
        if set(new_medoids) == set(medoids):
            break

        # Reset clusters for next iteration
        medoids = new_medoids
        clusters = {medoid: [] for medoid in medoids}

    # Convert dictionary to list of clusters for final output
    return list(clusters.values())


# Example usage with Levenshtein distance
def levenshtein(s1, s2):
    if len(s1) < len(s2):
        return levenshtein(s2, s1)

    if len(s2) == 0:
        return len(s1)

    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row

    return previous_row[-1]


def phonetic_distance(word1, word2):
    metaphone1 = doublemetaphone(word1)
    metaphone2 = doublemetaphone(word2)

    return min(levenshtein(metaphone1[0], metaphone2[0]), levenshtein(metaphone1[1], metaphone2[1]))


# Usage
word1 = "knight"
word2 = "night"
print(phonetic_distance(word1, word2))


def read_file_to_list(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()
    return [line.strip() for line in lines]


def remove_bracketed_content(s):
    return re.sub(r'\[.*?\]', '', s).strip()


if __name__ == "__main__":

    filename = "strings-en.txt"  # Replace with your file name
    raw_list = read_file_to_list(filename)
    strings = []

    for line in raw_list:
        aux = remove_bracketed_content(line)
        if len(aux) > 0:
            strings.append(aux)

    # Example strings and K value
    # strings = ["apple", "banana", "cherry", "date", "elderberry"]

    K = 100

    # Perform k-medoids clustering
    clusters = k_medoids(K, strings[:1000], levenshtein)

    for c in clusters:
        print(c)
